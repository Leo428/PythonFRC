#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    zC,             sensorAccelerometer)
#pragma config(Sensor, in2,    xC,             sensorAccelerometer)
#pragma config(Sensor, in3,    yC,             sensorAccelerometer)
#pragma config(Sensor, I2C_1,  backLeftEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  frontLeftEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  frontRightEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  backRightEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           backLeftControl, tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           backLeftDrive, tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port4,           frontLeftControl, tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port5,           frontLeftDrive, tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port6,           frontRightControl, tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port7,           frontRightDrive, tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port9,           backRightDrive, tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port10,          backRightControl, tmotorVex393_HBridge, openLoop, encoderPort, I2C_4)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int encoderInit = 0;

void recoverControlMotor(){
	if(nMotorEncoder[frontRightControl] != encoderInit){
		while(nMotorEncoder[frontRightControl] > encoderInit){
			motor[frontRightControl] = -127;
		}
		while(nMotorEncoder[frontRightControl] < encoderInit){
			motor[frontRightControl] = 127;
		}
	}//frontRight
	if(nMotorEncoder[frontLeftControl] != encoderInit){
		while(nMotorEncoder[frontLeftControl] > encoderInit){
			motor[frontLeftControl] = -127;
		}
		while(nMotorEncoder[frontLeftControl] < encoderInit){
			motor[frontRightControl] = 127;
		}
	}//frontLeft
	if(nMotorEncoder[backRightControl] != encoderInit){
		while(nMotorEncoder[backRightControl] > encoderInit){
			motor[backRightControl] = -127;
		}
		while(nMotorEncoder[backRightControl] < encoderInit){
			motor[backRightControl] = 127;
		}
	}//backRight
	if(nMotorEncoder[backLeftControl] != encoderInit){
		while(nMotorEncoder[backLeftControl] > encoderInit){
			motor[backLeftControl] = -127;
		}
		while(nMotorEncoder[backLeftControl] < encoderInit){
			motor[backLeftControl] = 127;
		}
	}//backLeft
}

task main(){
	while(true){
		if(vexRT[Btn8D] == 1){
			recoverControlMotor();
		}
		//	motor[frontRightControl] = 50;
		//	motor[frontLeftControl] = 50;
		//	motor[backLeftControl] = 50;
		//	motor[backRightControl] = 50;

		//	motor[frontRightDrive] = 50;
		//	motor[frontLeftDrive] = 50;
		//	motor[backLeftDrive] = 50;
		//	motor[backRightDrive] = 50;
		//if(nMotorEncoder[frontRightControl] != 0){
		//while(nMotorEncoder[frontRightControl] > 0){
		//motor[frontRightControl] = -127;
		//}
		//	}
	}
}
